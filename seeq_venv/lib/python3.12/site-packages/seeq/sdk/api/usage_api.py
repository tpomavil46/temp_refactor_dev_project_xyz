# coding: utf-8

"""
    Seeq REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 66.4.0-v202412241102-CD
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import sys
import os
import re

from deprecated import deprecated
# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient
from ..models import *

class UsageApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def get_types(self, **kwargs):
        """
        Get the list of available types that can be used as filter values for the reporting endpoint
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_types(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: UsageTypesV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsageTypesV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_types_with_http_info(**kwargs)
        else:
            (data) = self.get_types_with_http_info(**kwargs)
            return data

    def get_types_with_http_info(self, **kwargs):
        """
        Get the list of available types that can be used as filter values for the reporting endpoint
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_types_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: UsageTypesV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsageTypesV1
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/usage/types', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'UsageTypesV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_usage(self, **kwargs):
        """
        Get usage records for the specified time range. Results will be sorted by date if aggregating by day or month, otherwise by amount descending and limited to the first 100000 records
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_usage(start_time=start_time_value, end_time=end_time_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str start_time: Start time for the time frame (YYYY-MM-DDThh:mm:ss±hh:mm) (required)
        :param str end_time: End time for the time frame (YYYY-MM-DDThh:mm:ss±hh:mm) (required)
        :param list[str] type: Filter by type of usage (e.g. Analysis, Screenshot)
        :param str source: Filter by any part of the origin label or origin url fields
        :param str unit: Filter by the unit that the usage is measured in (e.g. Bytes, Credits, Any). Default is Bytes.
        :param list[str] identity_id: Filter by the UUID of the user who initiated the request
        :param list[str] aggregate_by: Aggregate the usage records by one or more fields. Cannot aggregate by both Day and Month at the same time.
        :param list[str] cache_types: The cache types to include in this query. If not set all will be returned.
        :return: UsageOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsageOutputListV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_usage_with_http_info(**kwargs)
        else:
            (data) = self.get_usage_with_http_info(**kwargs)
            return data

    def get_usage_with_http_info(self, **kwargs):
        """
        Get usage records for the specified time range. Results will be sorted by date if aggregating by day or month, otherwise by amount descending and limited to the first 100000 records
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_usage_with_http_info(start_time=start_time_value, end_time=end_time_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str start_time: Start time for the time frame (YYYY-MM-DDThh:mm:ss±hh:mm) (required)
        :param str end_time: End time for the time frame (YYYY-MM-DDThh:mm:ss±hh:mm) (required)
        :param list[str] type: Filter by type of usage (e.g. Analysis, Screenshot)
        :param str source: Filter by any part of the origin label or origin url fields
        :param str unit: Filter by the unit that the usage is measured in (e.g. Bytes, Credits, Any). Default is Bytes.
        :param list[str] identity_id: Filter by the UUID of the user who initiated the request
        :param list[str] aggregate_by: Aggregate the usage records by one or more fields. Cannot aggregate by both Day and Month at the same time.
        :param list[str] cache_types: The cache types to include in this query. If not set all will be returned.
        :return: UsageOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsageOutputListV1
        """

        all_params = ['start_time', 'end_time', 'type', 'source', 'unit', 'identity_id', 'aggregate_by', 'cache_types']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start_time' is set
        if ('start_time' not in params) or (params['start_time'] is None):
            raise ValueError("Missing the required parameter `start_time` when calling `get_usage`")
        # verify the required parameter 'end_time' is set
        if ('end_time' not in params) or (params['end_time'] is None):
            raise ValueError("Missing the required parameter `end_time` when calling `get_usage`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_time' in params:
            query_params.append(('startTime', params['start_time']))
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))
        if 'type' in params:
            query_params.append(('type', params['type']))
            collection_formats['type'] = 'multi'
        if 'source' in params:
            query_params.append(('source', params['source']))
        if 'unit' in params:
            query_params.append(('unit', params['unit']))
        if 'identity_id' in params:
            query_params.append(('identityId', params['identity_id']))
            collection_formats['identityId'] = 'multi'
        if 'aggregate_by' in params:
            query_params.append(('aggregateBy', params['aggregate_by']))
            collection_formats['aggregateBy'] = 'multi'
        if 'cache_types' in params:
            query_params.append(('cacheTypes', params['cache_types']))
            collection_formats['cacheTypes'] = 'multi'

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/usage', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'UsageOutputListV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
