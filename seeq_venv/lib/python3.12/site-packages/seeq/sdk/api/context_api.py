# coding: utf-8

"""
    Seeq REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 66.4.0-v202412241102-CD
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import sys
import os
import re

from deprecated import deprecated
# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient
from ..models import *

class ContextApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def batch_create_context_labels(self, **kwargs):
        """
        Create or update multiple labels
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_create_context_labels(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[ContextLabelWithIdInputV1] body: Context label information (required)
        :param str item_id: ID of the item that the labels are associated with (required)
        :return: list[ContextLabelOutputV1]
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ContextLabelOutputV1]
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.batch_create_context_labels_with_http_info(**kwargs)
        else:
            (data) = self.batch_create_context_labels_with_http_info(**kwargs)
            return data

    def batch_create_context_labels_with_http_info(self, **kwargs):
        """
        Create or update multiple labels
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_create_context_labels_with_http_info(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[ContextLabelWithIdInputV1] body: Context label information (required)
        :param str item_id: ID of the item that the labels are associated with (required)
        :return: list[ContextLabelOutputV1]
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ContextLabelOutputV1]
        """

        all_params = ['body', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_context_labels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `batch_create_context_labels`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `batch_create_context_labels`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/labels/batch', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'list[ContextLabelOutputV1]'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_context_comment(self, **kwargs):
        """
        Create a new comment associated with an Item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_comment(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextCommentInputV1 body: Context comment information (required)
        :param str item_id: ID of the item that the comment is associated with (required)
        :return: ContextCommentOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextCommentOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_context_comment_with_http_info(**kwargs)
        else:
            (data) = self.create_context_comment_with_http_info(**kwargs)
            return data

    def create_context_comment_with_http_info(self, **kwargs):
        """
        Create a new comment associated with an Item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_comment_with_http_info(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextCommentInputV1 body: Context comment information (required)
        :param str item_id: ID of the item that the comment is associated with (required)
        :return: ContextCommentOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextCommentOutputV1
        """

        all_params = ['body', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_context_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_context_comment`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `create_context_comment`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/comments', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextCommentOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_context_label(self, **kwargs):
        """
        Create a new label associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_label(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextLabelInputV1 body: Context label information (required)
        :param str item_id: ID of the item that the label is associated with (required)
        :return: ContextLabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextLabelOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_context_label_with_http_info(**kwargs)
        else:
            (data) = self.create_context_label_with_http_info(**kwargs)
            return data

    def create_context_label_with_http_info(self, **kwargs):
        """
        Create a new label associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_label_with_http_info(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextLabelInputV1 body: Context label information (required)
        :param str item_id: ID of the item that the label is associated with (required)
        :return: ContextLabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextLabelOutputV1
        """

        all_params = ['body', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_context_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_context_label`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `create_context_label`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/labels', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextLabelOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_context_numeric(self, **kwargs):
        """
        Create a new numeric context associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_numeric(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextNumericInputV1 body: Context numeric information (required)
        :param str item_id: ID of the item that the numeric context is associated with (required)
        :return: ContextNumericOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextNumericOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_context_numeric_with_http_info(**kwargs)
        else:
            (data) = self.create_context_numeric_with_http_info(**kwargs)
            return data

    def create_context_numeric_with_http_info(self, **kwargs):
        """
        Create a new numeric context associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_numeric_with_http_info(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextNumericInputV1 body: Context numeric information (required)
        :param str item_id: ID of the item that the numeric context is associated with (required)
        :return: ContextNumericOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextNumericOutputV1
        """

        all_params = ['body', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_context_numeric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_context_numeric`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `create_context_numeric`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/numeric', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextNumericOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_context_opaque(self, **kwargs):
        """
        Create new opaque context associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_opaque(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextOpaqueInputV1 body: Context opaque information (required)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :return: ContextOpaqueOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextOpaqueOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_context_opaque_with_http_info(**kwargs)
        else:
            (data) = self.create_context_opaque_with_http_info(**kwargs)
            return data

    def create_context_opaque_with_http_info(self, **kwargs):
        """
        Create new opaque context associated with an item
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_context_opaque_with_http_info(body=body_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextOpaqueInputV1 body: Context opaque information (required)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :return: ContextOpaqueOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextOpaqueOutputV1
        """

        all_params = ['body', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_context_opaque" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_context_opaque`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `create_context_opaque`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/opaque', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextOpaqueOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_label(self, **kwargs):
        """
        Create a new label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_label(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelInputV1 body: Label information (required)
        :return: LabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_label_with_http_info(**kwargs)
        else:
            (data) = self.create_label_with_http_info(**kwargs)
            return data

    def create_label_with_http_info(self, **kwargs):
        """
        Create a new label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_label_with_http_info(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelInputV1 body: Label information (required)
        :return: LabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputV1
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_label`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_label_category(self, **kwargs):
        """
        Create a new label category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_label_category(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelCategoryInputV1 body: Label category information (required)
        :return: LabelCategoryOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_label_category_with_http_info(**kwargs)
        else:
            (data) = self.create_label_category_with_http_info(**kwargs)
            return data

    def create_label_category_with_http_info(self, **kwargs):
        """
        Create a new label category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_label_category_with_http_info(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelCategoryInputV1 body: Label category information (required)
        :return: LabelCategoryOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputV1
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_label_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_label_category`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/categories', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelCategoryOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_numeric_description(self, **kwargs):
        """
        Create a new numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_numeric_description(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NumericDescriptionInputV1 body:
        :return: NumericDescriptionOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumericDescriptionOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_numeric_description_with_http_info(**kwargs)
        else:
            (data) = self.create_numeric_description_with_http_info(**kwargs)
            return data

    def create_numeric_description_with_http_info(self, **kwargs):
        """
        Create a new numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_numeric_description_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NumericDescriptionInputV1 body:
        :return: NumericDescriptionOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumericDescriptionOutputV1
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_numeric_description" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/numeric', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'NumericDescriptionOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_context_comment(self, **kwargs):
        """
        Delete or archive a comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_comment(item_id=item_id_value, comment_id=comment_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the comment is associated with (required)
        :param str comment_id: The comment ID to be deleted (required)
        :param bool delete: Permanently and irretrievably delete the comment
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_context_comment_with_http_info(**kwargs)
        else:
            (data) = self.delete_context_comment_with_http_info(**kwargs)
            return data

    def delete_context_comment_with_http_info(self, **kwargs):
        """
        Delete or archive a comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_comment_with_http_info(item_id=item_id_value, comment_id=comment_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the comment is associated with (required)
        :param str comment_id: The comment ID to be deleted (required)
        :param bool delete: Permanently and irretrievably delete the comment
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['item_id', 'comment_id', 'delete']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_context_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `delete_context_comment`")
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `delete_context_comment`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = []
        if 'delete' in params:
            query_params.append(('delete', params['delete']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/comments/{commentId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_context_label(self, **kwargs):
        """
        Delete or archive a label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_label(item_id=item_id_value, label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the label is associated with (required)
        :param str label_id: The context label ID to be deleted (required)
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_context_label_with_http_info(**kwargs)
        else:
            (data) = self.delete_context_label_with_http_info(**kwargs)
            return data

    def delete_context_label_with_http_info(self, **kwargs):
        """
        Delete or archive a label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_label_with_http_info(item_id=item_id_value, label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the label is associated with (required)
        :param str label_id: The context label ID to be deleted (required)
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['item_id', 'label_id', 'table_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_context_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `delete_context_label`")
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params) or (params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `delete_context_label`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'label_id' in params:
            path_params['labelId'] = params['label_id']

        query_params = []
        if 'table_id' in params:
            query_params.append(('tableId', params['table_id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/labels/{labelId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_context_numeric(self, **kwargs):
        """
        Delete or archive a numeric context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_numeric(item_id=item_id_value, numeric_context_id=numeric_context_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the numeric context is associated with (required)
        :param str numeric_context_id: The context numeric ID to be deleted (required)
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_context_numeric_with_http_info(**kwargs)
        else:
            (data) = self.delete_context_numeric_with_http_info(**kwargs)
            return data

    def delete_context_numeric_with_http_info(self, **kwargs):
        """
        Delete or archive a numeric context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_numeric_with_http_info(item_id=item_id_value, numeric_context_id=numeric_context_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the numeric context is associated with (required)
        :param str numeric_context_id: The context numeric ID to be deleted (required)
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['item_id', 'numeric_context_id', 'table_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_context_numeric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `delete_context_numeric`")
        # verify the required parameter 'numeric_context_id' is set
        if ('numeric_context_id' not in params) or (params['numeric_context_id'] is None):
            raise ValueError("Missing the required parameter `numeric_context_id` when calling `delete_context_numeric`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'numeric_context_id' in params:
            path_params['numericContextId'] = params['numeric_context_id']

        query_params = []
        if 'table_id' in params:
            query_params.append(('tableId', params['table_id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/numeric/{numericContextId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_context_opaque(self, **kwargs):
        """
        Delete or archive opaque context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_opaque(item_id=item_id_value, opaque_id=opaque_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :param str opaque_id: The opaque ID to be deleted (required)
        :param bool delete: Permanently and irretrievably delete the opaque context
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_context_opaque_with_http_info(**kwargs)
        else:
            (data) = self.delete_context_opaque_with_http_info(**kwargs)
            return data

    def delete_context_opaque_with_http_info(self, **kwargs):
        """
        Delete or archive opaque context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_context_opaque_with_http_info(item_id=item_id_value, opaque_id=opaque_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :param str opaque_id: The opaque ID to be deleted (required)
        :param bool delete: Permanently and irretrievably delete the opaque context
        :param str table_id: If provided, the ID of the Table Definition that will be used for permissions checking. The user needs read permissions on the provided table definition and theitem has to be in the table in order to create, update, or delete context. If not provided, the user must have read permissions on the item id the context is being applied to.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['item_id', 'opaque_id', 'delete', 'table_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_context_opaque" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `delete_context_opaque`")
        # verify the required parameter 'opaque_id' is set
        if ('opaque_id' not in params) or (params['opaque_id'] is None):
            raise ValueError("Missing the required parameter `opaque_id` when calling `delete_context_opaque`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'opaque_id' in params:
            path_params['opaqueId'] = params['opaque_id']

        query_params = []
        if 'delete' in params:
            query_params.append(('delete', params['delete']))
        if 'table_id' in params:
            query_params.append(('tableId', params['table_id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/opaque/{opaqueId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_label(self, **kwargs):
        """
        Delete a specific label.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_label(label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str label_id: ID of the label (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_label_with_http_info(**kwargs)
        else:
            (data) = self.delete_label_with_http_info(**kwargs)
            return data

    def delete_label_with_http_info(self, **kwargs):
        """
        Delete a specific label.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_label_with_http_info(label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str label_id: ID of the label (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['label_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params) or (params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `delete_label`")


        collection_formats = {}

        path_params = {}
        if 'label_id' in params:
            path_params['labelId'] = params['label_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/{labelId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_label_category(self, **kwargs):
        """
        Delete a specific label category.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_label_category(category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str category_id: ID of the category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_label_category_with_http_info(**kwargs)
        else:
            (data) = self.delete_label_category_with_http_info(**kwargs)
            return data

    def delete_label_category_with_http_info(self, **kwargs):
        """
        Delete a specific label category.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_label_category_with_http_info(category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str category_id: ID of the category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['category_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_label_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_id' is set
        if ('category_id' not in params) or (params['category_id'] is None):
            raise ValueError("Missing the required parameter `category_id` when calling `delete_label_category`")


        collection_formats = {}

        path_params = {}
        if 'category_id' in params:
            path_params['categoryId'] = params['category_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/categories/{categoryId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_numeric_description(self, **kwargs):
        """
        Delete a numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_numeric_description(numeric_description_id=numeric_description_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str numeric_description_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_numeric_description_with_http_info(**kwargs)
        else:
            (data) = self.delete_numeric_description_with_http_info(**kwargs)
            return data

    def delete_numeric_description_with_http_info(self, **kwargs):
        """
        Delete a numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_numeric_description_with_http_info(numeric_description_id=numeric_description_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str numeric_description_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        all_params = ['numeric_description_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_numeric_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'numeric_description_id' is set
        if ('numeric_description_id' not in params) or (params['numeric_description_id'] is None):
            raise ValueError("Missing the required parameter `numeric_description_id` when calling `delete_numeric_description`")


        collection_formats = {}

        path_params = {}
        if 'numeric_description_id' in params:
            path_params['numericDescriptionId'] = params['numeric_description_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/numeric/{numericDescriptionId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', None),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def find_label_categories(self, **kwargs):
        """
        Get all label categories
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_label_categories(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str parent_id: If set to the ID of a parent category then the child categories will be returned; if set to the empty GUID (00000000-0000-0000-0000-000000000000) only top level categories will be returned; if not specified all categories will be returned
        :return: LabelCategoryOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputListV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_label_categories_with_http_info(**kwargs)
        else:
            (data) = self.find_label_categories_with_http_info(**kwargs)
            return data

    def find_label_categories_with_http_info(self, **kwargs):
        """
        Get all label categories
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_label_categories_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str parent_id: If set to the ID of a parent category then the child categories will be returned; if set to the empty GUID (00000000-0000-0000-0000-000000000000) only top level categories will be returned; if not specified all categories will be returned
        :return: LabelCategoryOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputListV1
        """

        all_params = ['parent_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_label_categories" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent_id' in params:
            query_params.append(('parentId', params['parent_id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/categories', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelCategoryOutputListV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def find_labels(self, **kwargs):
        """
        Get all labels for a given category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_labels(category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str category_id: ID of the category of labels to return (required)
        :param str query: Search for labels that contain this string in a case-insensitive manner. This is especially useful for autocomplete categories. Note that if this is specified only the first 20 results will be returned, ordered by name
        :param str parent_id: If set to the ID of a parent label then the child labels will be returned; if set to the empty GUID (00000000-0000-0000-0000-000000000000) only top level labels will be returned; if not specified all labels will be returned
        :return: LabelOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputListV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_labels_with_http_info(**kwargs)
        else:
            (data) = self.find_labels_with_http_info(**kwargs)
            return data

    def find_labels_with_http_info(self, **kwargs):
        """
        Get all labels for a given category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_labels_with_http_info(category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str category_id: ID of the category of labels to return (required)
        :param str query: Search for labels that contain this string in a case-insensitive manner. This is especially useful for autocomplete categories. Note that if this is specified only the first 20 results will be returned, ordered by name
        :param str parent_id: If set to the ID of a parent label then the child labels will be returned; if set to the empty GUID (00000000-0000-0000-0000-000000000000) only top level labels will be returned; if not specified all labels will be returned
        :return: LabelOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputListV1
        """

        all_params = ['category_id', 'query', 'parent_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_labels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_id' is set
        if ('category_id' not in params) or (params['category_id'] is None):
            raise ValueError("Missing the required parameter `category_id` when calling `find_labels`")


        collection_formats = {}

        path_params = {}
        if 'category_id' in params:
            path_params['categoryId'] = params['category_id']

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))
        if 'parent_id' in params:
            query_params.append(('parentId', params['parent_id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/{categoryId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelOutputListV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_numeric_description(self, **kwargs):
        """
        Get numeric description by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_numeric_description(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id:
        :return: NumericDescriptionOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumericDescriptionOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_numeric_description_with_http_info(**kwargs)
        else:
            (data) = self.get_numeric_description_with_http_info(**kwargs)
            return data

    def get_numeric_description_with_http_info(self, **kwargs):
        """
        Get numeric description by ID
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_numeric_description_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id:
        :return: NumericDescriptionOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumericDescriptionOutputV1
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_numeric_description" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/numeric', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'NumericDescriptionOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_context_comment(self, **kwargs):
        """
        Update a comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_context_comment(body=body_value, item_id=item_id_value, comment_id=comment_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextCommentInputV1 body: Updated comment information (required)
        :param str item_id: ID of the item that the comment is associated with (required)
        :param str comment_id: ID of the comment to update (required)
        :return: ContextCommentOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextCommentOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_context_comment_with_http_info(**kwargs)
        else:
            (data) = self.update_context_comment_with_http_info(**kwargs)
            return data

    def update_context_comment_with_http_info(self, **kwargs):
        """
        Update a comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_context_comment_with_http_info(body=body_value, item_id=item_id_value, comment_id=comment_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextCommentInputV1 body: Updated comment information (required)
        :param str item_id: ID of the item that the comment is associated with (required)
        :param str comment_id: ID of the comment to update (required)
        :return: ContextCommentOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextCommentOutputV1
        """

        all_params = ['body', 'item_id', 'comment_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_context_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_context_comment`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `update_context_comment`")
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `update_context_comment`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/comments/{commentId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextCommentOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_context_opaque(self, **kwargs):
        """
        Update opaque context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_context_opaque(body=body_value, item_id=item_id_value, opaque_id=opaque_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextOpaqueInputV1 body: Updated opaque context information (required)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :param str opaque_id: ID of the opaque context to update (required)
        :return: ContextOpaqueOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextOpaqueOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_context_opaque_with_http_info(**kwargs)
        else:
            (data) = self.update_context_opaque_with_http_info(**kwargs)
            return data

    def update_context_opaque_with_http_info(self, **kwargs):
        """
        Update opaque context
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_context_opaque_with_http_info(body=body_value, item_id=item_id_value, opaque_id=opaque_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ContextOpaqueInputV1 body: Updated opaque context information (required)
        :param str item_id: ID of the item that the opaque context is associated with (required)
        :param str opaque_id: ID of the opaque context to update (required)
        :return: ContextOpaqueOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextOpaqueOutputV1
        """

        all_params = ['body', 'item_id', 'opaque_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_context_opaque" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_context_opaque`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `update_context_opaque`")
        # verify the required parameter 'opaque_id' is set
        if ('opaque_id' not in params) or (params['opaque_id'] is None):
            raise ValueError("Missing the required parameter `opaque_id` when calling `update_context_opaque`")


        collection_formats = {}

        path_params = {}
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']
        if 'opaque_id' in params:
            path_params['opaqueId'] = params['opaque_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/{itemId}/opaque/{opaqueId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextOpaqueOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_label(self, **kwargs):
        """
        Update a label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_label(body=body_value, label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelInputV1 body: New name for the label (required)
        :param str label_id: (required)
        :return: LabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_label_with_http_info(**kwargs)
        else:
            (data) = self.update_label_with_http_info(**kwargs)
            return data

    def update_label_with_http_info(self, **kwargs):
        """
        Update a label
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_label_with_http_info(body=body_value, label_id=label_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelInputV1 body: New name for the label (required)
        :param str label_id: (required)
        :return: LabelOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelOutputV1
        """

        all_params = ['body', 'label_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_label`")
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params) or (params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `update_label`")


        collection_formats = {}

        path_params = {}
        if 'label_id' in params:
            path_params['labelId'] = params['label_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/{labelId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_label_category(self, **kwargs):
        """
        Update a label category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_label_category(body=body_value, category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelCategoryInputV1 body: Label category information (required)
        :param str category_id: (required)
        :return: LabelCategoryOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_label_category_with_http_info(**kwargs)
        else:
            (data) = self.update_label_category_with_http_info(**kwargs)
            return data

    def update_label_category_with_http_info(self, **kwargs):
        """
        Update a label category
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_label_category_with_http_info(body=body_value, category_id=category_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LabelCategoryInputV1 body: Label category information (required)
        :param str category_id: (required)
        :return: LabelCategoryOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LabelCategoryOutputV1
        """

        all_params = ['body', 'category_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_label_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_label_category`")
        # verify the required parameter 'category_id' is set
        if ('category_id' not in params) or (params['category_id'] is None):
            raise ValueError("Missing the required parameter `category_id` when calling `update_label_category`")


        collection_formats = {}

        path_params = {}
        if 'category_id' in params:
            path_params['categoryId'] = params['category_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/labels/categories/{categoryId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'LabelCategoryOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_numeric_description(self, **kwargs):
        """
        Update a numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_numeric_description(body=body_value, numeric_description_id=numeric_description_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NumericDescriptionInputV1 body: New value for the numeric description (required)
        :param str numeric_description_id: (required)
        :return: ContextNumericOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextNumericOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_numeric_description_with_http_info(**kwargs)
        else:
            (data) = self.update_numeric_description_with_http_info(**kwargs)
            return data

    def update_numeric_description_with_http_info(self, **kwargs):
        """
        Update a numeric description
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_numeric_description_with_http_info(body=body_value, numeric_description_id=numeric_description_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NumericDescriptionInputV1 body: New value for the numeric description (required)
        :param str numeric_description_id: (required)
        :return: ContextNumericOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContextNumericOutputV1
        """

        all_params = ['body', 'numeric_description_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_numeric_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_numeric_description`")
        # verify the required parameter 'numeric_description_id' is set
        if ('numeric_description_id' not in params) or (params['numeric_description_id'] is None):
            raise ValueError("Missing the required parameter `numeric_description_id` when calling `update_numeric_description`")


        collection_formats = {}

        path_params = {}
        if 'numeric_description_id' in params:
            path_params['numericDescriptionId'] = params['numeric_description_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/context/numeric/{numericDescriptionId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ContextNumericOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
